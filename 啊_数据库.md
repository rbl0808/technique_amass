### 开发规范：

1. 避免数据类型的隐式转换
2. 充分利用索引，避免索引失效
3. 程序连接不同数据库时使用不同的账号，禁止跨库查询
4. 禁止使用select *，指定列名查询
5. 禁止使用不含字段列表的insert语句
6. 避免使用子查询，将子查询优化为join操作(子查询结果集不使用索引)
7. 避免使用join关联太多表
8. 减少数据库交互次数



###  MyISAM和InnoDB的区别

1. MyIssAM使用表级锁；InnoDb使用行级锁和表级锁

2. MyIssAM不支持事务；InnoDB支持事务

3. MylssAM不支持崩溃回复；InnoDB支持崩溃回复

4. MylssAM不支持外键；InnoDB支持外键

    

### 事务的四大特性：

      1. 原子性（Atomicity）
         事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
      2. 一致性（Consistency）
         事务前后数据的完整性必须保持一致。
         - 事务开始和结束时，外部数据一致
         - 在整个事务过程中，操作是连续的
      3. 隔离性（Isolation）
         多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离。
      4. 持久性（Durability）
         一个事务一旦被提交，它对数据库中的数据改变就是永久性的。



###  隔离级别：

- 读未提交

- 读已提交

- 可重复读(default)

- 串行化

MVVC实现读未提交和可重复读，

- Record Lock : 单个记录行锁
- Gap Lock ：间隙锁，不包含记录本身
- next-key lock ：锁定一个范围，包含记录本身



### 索引：

- 主键索引

  数据表的主键列使用的就是主键索引。

  一张数据表有只能有一个主键，并且主键不能为null，不能重复。

  在mysql的InnoDB的表中，当没有显示的指定表的主键时，InnoDB会自动先检查表中是否有唯一索引的字段，如果有，则选择该字段为默认的主键，否则InnoDB将会自动创建一个6Byte的自增主键。

- 二级索引

  二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。

  唯一索引，普通索引，前缀索引等索引属于二级索引。

1. **唯一索引(Unique Key)** ：唯一索引也是一种约束。**唯一索引的属性列不能出现重复的数据，但是允许数据为NULL，一张表允许创建多个唯一索引。**建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。
2. **普通索引(Index)** ：**普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和NULL。**
3. **前缀索引(Prefix)** ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小，
   因为只取前几个字符。
4. **全文索引(Full Text)** ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6之前只有MYISAM引擎支持全文索引，5.6之后InnoDB也支持了全文索引。 

- 索引创建注意点
  1. 不为null的字段
  2. 被频繁查询的字段
  3. 被作为条件查询的字段
  4. 被经常用于连接的字段
  5. 尽可能创建联合索引
  6. 避免冗余索引和重复索引
     - 重复索引示例：primary key(id)、index(id)、unique index(id)
     - 冗余索引示例：index(a,b,c)、index(a,b)、index(a)
  7. 单张表上的索引不超过5个



​    基本架构(8.0之后没有查询缓存)

​		![](https://user-gold-cdn.xitu.io/2019/3/23/169a8bc60a083849?w=950&h=1062&f=jpeg&s=38189)



最开始 MySQL 并没与 InnoDB 引擎( InnoDB 引擎是其他公司以插件形式插入 MySQL 的) ，MySQL 自带的引擎是 MyISAM，但是我们知道 redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，binlog 日志只能用来归档。

并不是说只用一个日志模块不可以，只是 InnoDB 引擎就是通过 redo log 来支持事务的。那么，又会有同学问，我用两个日志模块，但是不要这么复杂行不行，为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做？

* **先写 redo log 直接提交，然后写 binlog**，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 bingog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。
* **先写 binlog，然后写 redo log**，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。

如果采用 redo log 两阶段提交的方式就不一样了，写完 binglog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？假设 redo log 处于预提交状态，binglog 也已经写完了，这个时候发生了异常重启会怎么样呢？
这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：

* 判断 redo log 是否完整，如果判断是完整的，就立即提交。
* 如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。

这样就解决了数据一致性的问题。



### 执行计划

 explain

​		![](https://images2018.cnblogs.com/blog/512541/201808/512541-20180803142201303-545775900.png)





| 信息          | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| id            | 查询的序号，包含一组数字，表示查询中执行select子句或操作表的顺序 **两种情况** id相同，执行顺序从上往下 id不同，id值越大，优先级越高，越先执行 |
| select_type   | 查询类型，主要用于区别普通查询，联合查询，子查询等的复杂查询                                                  1、simple ——简单的select查询，查询中不包含子查询或者UNION                                                         2、primary ——查询中若包含任何复杂的子部分，最外层查询被标记                                                   3、subquery——在select或where列表中包含了子查询                                                                                   4、derived——在from列表中包含的子查询被标记为derived（衍生），MySQL会递归执行这些子查询，把结果放到临时表中                                                                                                                                     5、union——如果第二个select出现在UNION之后，则被标记为UNION，如果union包含在from子句的子查询中，外层select被标记为derived                                                                                                     6、union result:UNION 的结果 |
| table         | 输出的行所引用的表                                           |
| type          | 显示联结类型，显示查询使用了何种类型，按照从最佳到最坏类型排序                                              1、system：表中仅有一行（=系统表）这是const联结类型的一个特例。                                                 2、const：表示通过索引一次就找到，const用于比较primary key或者unique索引。因为只匹配一行数据，所以如果将主键置于where列表中，mysql能将该查询转换为一个常量                                                                                                                3、eq_ref:唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于唯一索引或者主键扫描                                                                                                                                                                          4、ref:非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，可能会找多个符合条件的行，属于查找和扫描的混合体                                                                                                                         5、range:只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引，一般就是where语句中出现了between,in等范围的查询。这种范围扫描索引扫描比全表扫描要好，因为它开始于索引的某一个点，而结束另一个点，不用全表扫描                                                                                                                                          6、index:index 与all区别为index类型只遍历索引树。通常比all快，因为索引文件比数据文件小很多。                                                                                                                                                                                   7、all：遍历全表以找到匹配的行 注意:一般保证查询至少达到range级别，最好能达到ref。 |
| possible_keys | 指出MySQL能使用哪个索引在该表中找到行                        |
| key           | 显示MySQL实际决定使用的键(索引)。如果没有选择索引,键是NULL。查询中如果使用覆盖索引，则该索引和查询的select字段重叠。 |
| key_len       | 表示索引中使用的字节数，该列计算查询中使用的索引的长度在不损失精度的情况下，长度越短越好。如果键是NULL,则长度为NULL。该字段显示为索引字段的最大可能长度，并非实际使用长度。 |
| ref           | 显示索引的哪一列被使用了，如果有可能是一个常数，哪些列或常量被用于查询索引列上的值 |
| rows          | 根据表统计信息以及索引选用情况，大致估算出找到所需的记录所需要读取的行数 |
| Extra         | 包含不适合在其他列中显示，但是十分重要的额外信息                                                                                1、Using filesort：说明mysql会对数据适用一个外部的索引排序。而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成排序操作称为“文件排序”                                                           2、Using temporary:使用了临时表保存中间结果，mysql在查询结果排序时使用临时表。常见于排序order by和分组查询group by。                                                                                                                    3、Using index:表示相应的select操作用使用覆盖索引，避免访问了表的数据行。如果同时出现using where，表名索引被用来执行索引键值的查找；如果没有同时出现using where，表名索引用来读取数据而非执行查询动作。                                                                                                                   4、Using where :表明使用where过滤                                                                                                                         5、using join buffer:使用了连接缓存                                                                                                                              6、impossible where:where子句的值总是false，不能用来获取任何元组                                              7、select tables optimized away：在没有group by子句的情况下，基于索引优化Min、max操作或者对于MyISAM存储引擎优化count（*），不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。                                                                                                                                                   8、distinct：优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作。 |



